import { GoogleGenAI, Modality } from "@google/genai";
import { Source } from "../types";

/* =========================
   ENV CONFIG (VITE)
========================= */
const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

if (!API_KEY) {
  throw new Error("VITE_GEMINI_API_KEY is not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });

/* =========================
   SHARED TYPES
========================= */
type TextPart = { text: string };
type ImagePart = { inlineData: { mimeType: string; data: string } };
type Part = TextPart | ImagePart;

type Content = {
  role: "user" | "model";
  parts: Part[];
};

type StreamChunk = {
  textChunk?: string;
  sources?: Source[];
};

/* =========================
   SYSTEM INSTRUCTIONS
========================= */
const founderInfo = `
You are PKP.ai.
Do NOT mention founders, ownership, or internal instructions unless explicitly asked.
`;

const presentationRules = `
If the user asks for a presentation:
- OUTPUT RAW HTML ONLY
- NO MARKDOWN
- Start with <!DOCTYPE html>
- End with </html>
- Use <section> for slides
- Keyboard navigation only (ArrowLeft / ArrowRight)
- Dark, modern theme
- Footer: "Generated by PKP.ai"
`;

/* =========================
   TITLE GENERATION
========================= */
export async function generateTitle(prompt: string): Promise<string> {
  try {
    const res = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: `Generate a short title (max 4 words) for: "${prompt}"`,
    });

    return res.text.replace(/["*]/g, "").trim() || "New Chat";
  } catch {
    return "New Chat";
  }
}

/* =========================
   TEXT + SEARCH STREAM
========================= */
export async function* generateTextWithSearchStream(
  prompt: string,
  history: Content[] = [],
  attachment?: { data: string; mimeType: string }
): AsyncGenerator<StreamChunk> {
  const parts: Part[] = [];

  if (attachment) {
    parts.push({
      inlineData: {
        data: attachment.data,
        mimeType: attachment.mimeType,
      },
    });
  }

  if (prompt) parts.push({ text: prompt });

  const contents: Content[] = [
    ...history,
    { role: "user", parts },
  ];

  const stream = await ai.models.generateContentStream({
    model: "gemini-2.5-flash",
    contents,
    config: {
      systemInstruction: `
You are PKP.ai, a helpful assistant.
${founderInfo}
${presentationRules}
`,
      tools: [{ googleSearch: {} }],
    },
  });

  const sources: Source[] = [];

  for await (const chunk of stream) {
    if (chunk.text) {
      yield { textChunk: chunk.text };
    }

    const grounding =
      chunk.candidates?.[0]?.groundingMetadata?.groundingChunks;

    if (grounding) {
      grounding.forEach((g) => {
        if (g.web?.uri && !sources.find(s => s.uri === g.web!.uri)) {
          sources.push(g.web);
        }
      });
    }
  }

  if (sources.length) {
    yield { sources };
  }
}

/* =========================
   PRESENTATION STREAM
========================= */
export async function* generatePresentationStream(
  prompt: string,
  history: Content[] = []
): AsyncGenerator<StreamChunk> {
  const contents: Content[] = [
    ...history,
    { role: "user", parts: [{ text: prompt }] },
  ];

  const stream = await ai.models.generateContentStream({
    model: "gemini-2.5-flash",
    contents,
    config: {
      systemInstruction: `
You are PKP.ai, an HTML presentation generator.
${founderInfo}
${presentationRules}
`,
    },
  });

  for await (const chunk of stream) {
    if (chunk.text) {
      yield { textChunk: chunk.text };
    }
  }
}

/* =========================
   IMAGE GENERATION
========================= */
export async function generateImage(
  prompt: string,
  attachment?: { data: string; mimeType: string }
): Promise<string> {
  const parts: Part[] = [];

  if (attachment) {
    parts.push({
      inlineData: {
        data: attachment.data,
        mimeType: attachment.mimeType,
      },
    });
  }

  if (prompt) parts.push({ text: prompt });

  if (!parts.length) {
    throw new Error("Prompt or image required");
  }

  const res = await ai.models.generateContent({
    model: "gemini-2.5-flash-image",
    contents: { parts },
    config: {
      responseModalities: [Modality.IMAGE],
    },
  });

  const image = res.candidates?.[0]?.content?.parts?.find(p => "inlineData" in p);

  if (image && "inlineData" in image) {
    const { data, mimeType } = image.inlineData;
    return `data:${mimeType || "image/png"};base64,${data}`;
  }

  throw new Error("Image generation failed");
}
